#include "arith.gh"
#include "nth_prop.gh"
#include "modulo.gh"
#include <nat.gh>
#include <list.gh>

predicate coprime(int n1, int n2) = gcd(n1, n2) == 1;

fixpoint bool divide(int whole, int divisor)
{
  return whole/divisor * divisor == whole;
}

lemma void one_divide_all(int whole)
requires true;
ensures divide(whole, 1) == true;
{
  div_rem(whole, 1);
}

lemma void divisor_below_n(int whole, int divisor)
requires divisor > whole &*& whole > 0 &*& divisor > 0;
ensures divide(whole, divisor) == false;
{
  division_round_to_zero(whole, divisor);
  assert whole/divisor == 0;
  mul_subst(0, whole/divisor, divisor);
}

fixpoint bool divisors_fp(int whole, pair<int, bool> n_divide)
{
  return divide(whole, fst(n_divide)) == snd(n_divide);
}

fixpoint bool common_divisors_fp(int whole1, int whole2, pair<int, bool> n_divide)
{
  return divide(whole1, fst(n_divide)) == divide(whole2, fst(n_divide)) && divide(whole1, fst(n_divide)) == true;
}

fixpoint list<pair<int, bool> > gen_divisors(nat bound, int whole)
{
  switch(bound) {
    case zero: return nil;
    case succ(p_bound): return cons(pair(int_of_nat(bound), divide(whole, int_of_nat(bound))), gen_divisors(p_bound, whole));
  }
}

lemma void gen_divisors_contains_1(nat bound, int whole)
requires gen_divisors(succ(bound), whole) == cons(?pair, ?tail);
ensures true == exists(gen_divisors(succ(bound), whole), (equals)(pair(1, true)));
{
  switch(bound) {
    case(zero): {
      assert int_of_nat(succ(bound)) == 1;
      one_divide_all(whole);
      assert pair == pair(1, true);
    }
    case(succ(p_bound)): {
      gen_divisors_contains_1(p_bound, whole);
      assert true == exists(tail, (equals)(pair(1, true)));
    }
  }
}

lemma void length_gen_divisors(nat bound, int whole)
requires true;
ensures length(gen_divisors(bound, whole)) == int_of_nat(bound);
{
  switch(bound) {
    case zero: 
    case succ(p_bound): length_gen_divisors(p_bound, whole);
  }
}

lemma void gen_divisor_contains_all_divisors_below_bound(nat bound, int whole, int divisor)
requires whole >= 0 &*& int_of_nat(bound) >= divisor &*& divisor > 0;
ensures divide(whole, divisor) ? true == exists(gen_divisors(bound, whole), (equals)(pair(divisor, true))) : true == exists(gen_divisors(bound, whole), (equals)(pair(divisor, false)));
{
  switch(bound) {
    case zero: 
    case succ(p_bound): {
      if(int_of_nat(bound) == divisor) {
        list<pair<int, bool> > divs = gen_divisors(bound, whole);
        pair<int, bool> hd = head(divs);
        assert divs == cons(pair(int_of_nat(bound), divide(whole, int_of_nat(bound))), gen_divisors(p_bound, whole));
      } else {
        gen_divisor_contains_all_divisors_below_bound(p_bound, whole, divisor);
      }
    }
  }
}

fixpoint bool snd_true(pair<int, bool> p)
{
  return snd(p) == true;
}

fixpoint bool leq_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) >= fst(b);
}

fixpoint bool geq_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) <= fst(b);
}

fixpoint bool greater_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) < fst(b);
}

fixpoint bool less_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) > fst(b);
}

fixpoint bool neq<t>(t a, t b)
{
  return a != b;
}

fixpoint bool equals<t>(t a, t b)
{
  return a == b;
}

lemma void all_divisors_in_gen_divisors(int whole, int n)
requires n > 0 &*& whole > 0;
ensures divide(whole, n) ? true == exists(gen_divisors(nat_of_int(whole), whole), (equals)(pair(n, true))) : true;
{
  if(n > whole) {
    divisor_below_n(whole, n);
  } else {
    gen_divisor_contains_all_divisors_below_bound(nat_of_int(whole), whole, n);
  }
}

lemma void gen_divisors_head(list<pair<int, bool> > lst, nat bound, int whole)
requires lst == gen_divisors(bound, whole);
ensures bound == zero ? true : true == divisors_fp(whole, head(lst));
{
  length_gen_divisors(bound, whole);
  assert length(lst) == int_of_nat(bound);
  switch(bound) {
    case zero:
    case succ(p_bound):
  } 
}

lemma void gen_divisors_tail(list<pair<int, bool> > lst, nat s_bound, int whole)
requires lst == gen_divisors(s_bound, whole) &*& s_bound == succ(?bound);
ensures tail(lst) == gen_divisors(bound, whole);
{
}

lemma void forall_gen_divisor_contains_divisors(list<pair<int, bool> > lst, int whole)
requires lst == gen_divisors(nat_of_int(length(lst)), whole);
ensures true == forall(lst, (divisors_fp)(whole));
{
  switch(lst) {
    case nil:
    case cons(pair, tl): {
      gen_divisors_tail(lst, succ(nat_of_int(length(tl))), whole);
      forall_gen_divisor_contains_divisors(tl, whole);
      assert true == forall(tl, (divisors_fp)(whole));
    }
  }
}

fixpoint list<pair<int, bool> > merge_list_and(list<pair<int, bool> > lst1, list<pair<int, bool> > lst2)
{
  switch(lst1) {
    case nil: return nil;
    case cons(pair1, tail1): return nil; /*{ // verifast issue #79
      switch(lst2) {
        case nil: return nil;
        case cons(pair2, tail2): return (pair1 == pair2 && snd(pair1) == true) ? cons(pair1, merge_list_and(tail1, tail2)) : merge_list_and(tail1, tail2);
      }
    }; */
  }
}

// Rely on fixpoint
lemma void merge_list_and_lemma(list<pair<int, bool> > lst1, list<pair<int, bool> > lst2, pair<int, bool> pair)
requires true == exists(lst1, (equals)(pair)) &*& true == exists(lst2, (equals)(pair)) &*& snd(pair) == true;
ensures true == exists(merge_list_and(lst1, lst2), (equals)(pair));
{
  assume(false);
}

lemma void common_divisors_contains_1(int n1, int n2)
requires n1 >= n2 &*& n2 > 0;
ensures true == exists(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)), (equals)(pair(1, true)));
{
  gen_divisors_contains_1(nat_of_int(n1-1), n1);
  gen_divisors_contains_1(nat_of_int(n2-1), n2);
  merge_list_and_lemma(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2), pair(1, true));
}

lemma void not_exists_prop_to_not_exists<t>(list<t> lst, fixpoint(t, bool) prop, t elem)
requires false == exists(lst, prop) &*& true == prop(elem);
ensures false == exists(lst, (equals)(elem));
{
  switch(lst)
  {
    case nil:
    case cons(hd, tl): {
      if(hd == elem){}
      not_exists_prop_to_not_exists(tl, prop, elem);
    }
  }
}

lemma void common_divisors_contains_all_divisors(int n1, int n2, int n3)
requires divide(n1, n3) == true && divide(n2, n3) == true &*& n1 > 0 &*& n2 > 0 &*& n3 > 0;
ensures true == exists(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)), (equals)(pair(n3, true)));
{
  if(n3 > n1)
  {
    divisor_below_n(n1, n3);
  }
  gen_divisor_contains_all_divisors_below_bound(nat_of_int(n1), n1, n3);
  assert true == exists(gen_divisors(nat_of_int(n1), n1), (equals)(pair(n3, true)));
  
  if(n3 > n2)
  {
    divisor_below_n(n2, n3);
  }
  gen_divisor_contains_all_divisors_below_bound(nat_of_int(n2), n2, n3);
  assert true == exists(gen_divisors(nat_of_int(n2), n2), (equals)(pair(n3, true)));
  
  merge_list_and_lemma(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2), pair(n3, true));
}

// Rely on fixpoint
lemma void common_divisors(int n1, int n2)
requires n1 >= n2;
ensures true == forall(merge_list_and(gen_divisors(nat_of_int(n2), n1), gen_divisors(nat_of_int(n2), n2)), (common_divisors_fp)(n1, n2));
{
  assume(false);
}

fixpoint pair<int, bool> greatest_common_divisor(list<pair<int, bool> > common_divisors)
{
  switch(common_divisors) {
    case nil: return pair(0, false);
    case cons(pair, tail): return snd(pair) == true && (greater_than(greatest_common_divisor(tail), pair) || snd(greatest_common_divisor(tail)) == false) ? pair : greatest_common_divisor(tail);
  }
}

lemma void greatest_common_divisor_tail_less_than(list<pair<int, bool> > lst)
requires true;
ensures false == leq_than(greatest_common_divisor(lst), greatest_common_divisor(tail(lst))) ? snd(greatest_common_divisor(tail(lst))) == false : true;
{
  switch(lst){
    case nil:
    case cons(hd, tl): {
      pair<int, bool> gcd = greatest_common_divisor(lst);
      pair<int, bool> p_gcd = greatest_common_divisor(tail(lst));
      
      if(snd(p_gcd) == true){
        if(snd(hd) == false) {
        } else {
        } 
      } else { // snd(p_gcd) == false;
        if(snd(hd) == false) {
        } else {
        }
      }
    }
  }
}

lemma void greatest_common_divisor_return_true_divisor_iff_exists(list<pair<int, bool> > lst)
requires true;
ensures true == exists(lst, snd_true) ? snd(greatest_common_divisor(lst)) == true : snd(greatest_common_divisor(lst)) == false;
{
  switch(lst)
  {
    case nil:
    case cons(hd, tl): {
      greatest_common_divisor_return_true_divisor_iff_exists(tl);
    }
  }
}

lemma void greatest_common_divisor_l(list<pair<int, bool> > common_divisors, int n3)
requires greatest_common_divisor(common_divisors) == pair(?gcd, ?true_divisor) &*& (n3 > gcd || true_divisor == false);
ensures false == exists(common_divisors, (equals)(pair(n3, true)));
{    
  switch(common_divisors){
    case nil:
    case cons(hd, tl): {
      if(true_divisor == true) {
        greatest_common_divisor_tail_less_than(common_divisors);
        greatest_common_divisor_l(tl, n3);
        assert greatest_common_divisor(tl) == pair(?p_gcd, ?p_true_divisor);
        assert hd != pair(n3, true);
      } else {
        greatest_common_divisor_return_true_divisor_iff_exists(common_divisors);
        if(true == exists(common_divisors, (equals)(pair(n3, true)))) {
          assert exists(common_divisors, snd_true) == false;
          assert true == snd_true(pair(n3, true));
          not_exists_prop_to_not_exists(common_divisors, snd_true, pair(n3, true));
        }
      }
    }
  }
}

fixpoint int gcd(int n1, int n2)
{
  return fst(greatest_common_divisor(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2))));
}

lemma void gcd_holds(int n1, int n2, int n3)
requires n1 >= n2 &*& n3 > gcd(n1, n2) &*& n3 > 0 &*& n1 > 0 &*& n2 > 0;
ensures divide(n1, n3) == true ? divide(n2, n3) == false : true;
{
  if(divide(n1, n3) == true) {
    if(divide(n2, n3) == true) {
      common_divisors_contains_all_divisors(n1, n2, n3);
      greatest_common_divisor_l(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)), n3);
    }
  } 
}


// x = diff * step
lemma void bin_chinese_remainder_theorem(int n1, int n2, int x)
requires coprime(n1, n2) &*& 0 == x%n1 &*& 0 == x % n2 &*& x < n1*n2 ;
ensures x == 0;
{
  assume(false);
}

 