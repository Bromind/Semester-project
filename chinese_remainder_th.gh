#ifndef CHINESE_REMAINDER_TH
#define CHINESE_REMAINDER_TH

#include "up_to_conversions.gh"
#include "arith.gh"
#include "nth_prop.gh"
#include "modulo.gh"
#include "gcd.gh"
#include "boolean_fixpoints.gh"
#include "protect.gh"
#include "divisors.gh"
#include "list_lemma.gh"
#include "list_merge_and.gh"
#include <nat.gh>
#include <list.gh>

lemma void close_mul_assoc(int n1, int n2, int n3)
  requires n2 >= 0;
  ensures protect(n1*n2*n3 == n2*n3*n1);
{
  mul_assoc(n1, n2, n3);
  close protect(n1*n2*n3 == n2*n3*n1);
}

lemma void x_not_1(int n1, int n2, int x)
requires 0 == x%n1 &*& 0 == x%n2 &*& x < (n1*n2) &*& n1 > 0 &*& n2 > 0;
ensures x != 1;
{
  assert x != n1*n2;
  note(x != n1*n2);
  close protect(x != n1*n2);
  if(x == 1) {
    if(n1 > 1) {
      division_round_to_zero(1, n1);
      div_rem(1, n1);
      assert x%n1 == 1;
      assert false;
    }
    
    if(n2 > 1) {
      division_round_to_zero(1, n2);
      div_rem(1, n2);
      assert x%n2 == 1;
      assert false;
    }
    assert n1*n2 == 1;
    assert x == n1*n2;
    open protect(x != n1*n2);
  } else {
    open protect(x != n1*n2);
  }
}


lemma void divide_inside_paren(int n1, int n2, int n3, int n4, int a)
requires n1 * (n2*a) == n3 * (n4 * a) &*& n1 >= 0 &*& n2 >= 0 &*& n3 >= 0 &*& n4 >= 0 &*& a > 0;
ensures n1 * n2 == n3 * n4;
{
  mul_assoc(a, n2, n1);
  mul_assoc(a, n4, n3);
  if(n1*n2 != n3*n4) {
    mul_nonnegative(n1, n2);
    mul_nonnegative(n3, n4);
    mul_subst_neq(n1*n2, n3*n4, a);
  }
}

lemma void mod_multiple(int n1, int n2)
requires n1 >= 0 &*& n2 > 0;
ensures 0 == (n1*n2)%n2;
{
  div_multiple(n1, n2);
  assert n1*n2/n2 == n1;

  int k = n1*n2;
  div_rem(k, n2);
  assert k == k/n2*n2 + k%n2;
  
  assert k == n1*n2 + k%n2;
}

lemma void gcd_mul(int n1, int n2, int n3)
requires coprime(n1, n3) &*& coprime(n2, n3) &*& n1 > 0 &*& n2 > 0 &*& n3 > 0;
ensures coprime(n1*n2, n3) &*& coprime(n1, n3) &*& coprime(n2, n3);
{
  assume(false);
}

lemma void close_div_rem(int a, int b)
requires b != 0;
ensures protect(a == a/b*b + a%b);
{
  div_rem(a, b);
  close protect(a == a/b*b + a%b);
}

lemma void is_zero(int x)
requires x >= 0 &*& false == (x >= 1);
ensures x == 0;
{
}

// x = diff * step
lemma void bin_chinese_remainder_theorem_helper(int n1, int n2, int x, nat loop_counter)
requires coprime(n1, n2) &*& 0 == x%n1 &*& 0 == x % n2 &*& x < (n1*n2) &*& n1 > 0 &*& n2 > 0 &*& x >= 0 &*& n2 <= int_of_nat(loop_counter);
ensures x == 0 &*& coprime(n1, n2);
{
  switch(loop_counter) {
  case zero: {
    assert n2 > 0;
    assert int_of_nat(loop_counter) == 0;
    assert n2 <= 0;
    
    assert false;
  }
  
  case succ(p_loop_counter): {
 
  if(1 == x) { // contradiction
    x_not_1(n1, n2, x);
  } else {
    assert x >= 0;
    if(x > 1) {
      close_div_rem(x, n1);
      close_div_rem(x, n2);
    
      int k1 = x/n1;
      quotient_positive(x, n1);
      int k2 = x/n2;
      int alpha = k2;
      
      open protect(x == x/n1*n1 + x%n1);
      assert x == k1*n1;
      close protect(x == k1*n1);
      if(k1 == 0){
        assert k1*n1 == 0;
        open protect(x == k1*n1);
        assert x == 0;
        //close protect(x == k1*n1);
        open protect(x > 1);
        assert false;
      } else {
        open protect(x == k1*n1);
      }
      open protect(x == x/n2*n2 + x%n2);
      assert x == k2*n2;
      close protect(x == k2*n2);
      assert k1*n1 == k2*n2;
    
      close_div_rem(k1, n2);
      open protect(k1 == k1/n2*n2 + k1%n2);
      note(k1 == k1/n2*n2 + k1%n2);
      close protect(k1 == k1/n2*n2 + k1%n2);
      
      int beta = k1/n2;
      assert k1 == n2*beta + k1%n2;
      note(k1 == n2*beta + k1%n2);
      
      if(k1%n2 == 0) {
        if(beta == 0) { // Prove that x == 0
          assert n2*beta == 0;
          assert k1%n2 == 0;
          assert beta == k1/n2;
          open protect(k1 == k1/n2*n2 + k1%n2);
          assert k1 == n2*beta + k1%n2;
          assert k1 == 0;
          open protect(x == k1*n1);
          assert x == k1*n1;
          assert x == 0*n1;
          assert x == 0;
        } else { // contradiction
          quotient_positive(x, n1);
          quotient_positive(x/n1, n2);
          assert beta >= 1;
          assert k1 == n2*beta;
          mul_mono(1, beta, n2);
          assert k1 >= n2;
          mul_mono(n2, k1, n1);
          assert x >= n1*n2;
          assert false;
        }
      } else { // k1%n2 != 0
        int a = gcd(k1, n2);
        quotient_positive(x, n1);
        gcd_geq_1(k1, n2);
        div_rem(n2, a);
        int b = n2/a;
        quotient_positive(n2, a);
        close protect(n2 == b* a + n2%a);
        assert n2 == b * a + n2%a;
        gcd_divide(k1, n2);
        assert n2%a == 0;
        open protect(n2 == b * a + n2%a);
        assert n2 == b * a;
        close protect(n2 == b*a);
        close protect(n2 == b* a + n2%a);
        note(n2 == b*a);
        if(b <= 0) {
          assert b*a == 0;
          open protect(n2 == b*a);
          assert n2 == b * a;
          assert false;
        }
        
        div_rem(k1, a);
        int gamma = k1/a;
        quotient_positive(k1, a);
        assert k1 == gamma * a;
        note(k1 == gamma * a);
        close protect(k1 == gamma * a);
        close protect(k1 == gamma * a);
        if(gamma <= 0)
        {
          assert gamma * a == 0;
          open protect(k1 == gamma * a);
          assert k1 == gamma * a;
          assert false;
        } else {
          open protect(k1 == gamma * a);
        }
       
        if(gcd(gamma, b) != 1)
        {
          int gcd = gcd(gamma, b);
          open protect(b >= 1);
          assert b >= 1;
          gcd_geq_1(gamma, b);
          gcd_divide(gamma, b);
          assert b%gcd == 0;
          close_div_rem(b, gcd);
          open protect(b == b/gcd*gcd + b%gcd);
          assert b == b/gcd*gcd + b%gcd;
          assert b == b/gcd*gcd;
          
          close_div_rem(gamma, gcd);
          open protect(gamma == gamma/gcd*gcd + gamma%gcd);
          assert gamma == gamma/gcd*gcd;
          
          assert k1 == a * (gamma/gcd * gcd);
          assert k1 == gamma/gcd * gcd * a;
          assert n2 == a * (b/gcd * gcd);
          mul_mono_strict(1, gcd, a);
          assert a*gcd > a;
          close_mul_assoc(gamma/gcd, gcd, a);
          open protect((gamma/gcd) * gcd * a == gcd * a * (gamma/gcd));
          assert true == ((gamma/gcd) * gcd * a == gcd * a * (gamma/gcd));
          assert k1 == gcd * a * (gamma/gcd);
          assert gamma >= 0;
          assert gcd > 0;
          quotient_positive(gamma, gcd);
          div_multiple(gamma/gcd, gcd * a);
          assert true == divide(k1, gcd * a);
          
          close_mul_assoc(b/gcd, gcd, a);
          open protect((b/gcd) * gcd * a == gcd * a * (b/gcd));
          assert n2 == a * gcd * (b/gcd);
          quotient_positive(b, gcd);
          div_multiple(b/gcd, gcd*a);
          assert true == divide(n2, gcd * a);
          
          gcd_holds(k1, n2, gcd*a);
          assert false;
          
          
        } else {
          open protect(b >= 1);
        }
        open protect(x == k1*n1);
        close protect(k1 == gamma * a);
        open protect(x == k2*n2);
        assert k1 * n1 == k2 * n2;
        assert n2 == b * a;
        close protect(n2 == b*a);
        quotient_positive(x, n2);
        mul_subst(n2, b*a, k2);
        assert k1 * n1 == k2 * (b * a);
        assert n1 * (gamma * a) == k2 * (b * a);
        divide_inside_paren(n1, gamma, k2, b, a);
        assert n1 * gamma == k2 * b;
        if(gcd(n1, b) != 1) {
          int gcd = gcd(n1, b);
          gcd_geq_1(n1, b);
          gcd_divide(n1, b);
          
          close_div_rem(n1, gcd);
          open protect(n1 == n1/gcd*gcd + n1%gcd);
          close_div_rem(b, gcd);
          open protect(b == b/gcd*gcd + b%gcd);
          
          assert true == divide(n1, gcd);
          assert true == divide(b, gcd);
          
          if(false == divide(n2, gcd)){
            int k = b/gcd;
            gcd_geq_1(n1, b);
            quotient_positive(b, gcd);
            assert k >= 0;
            assert n2 == a*b;
            assert b == b/gcd*gcd;
            mul_subst(b, k*gcd, a);
            mul_assoc(gcd, k, a);
            assert n2 == a*k*gcd;
            mul_nonnegative(a, k);
            div_multiple(a*k, gcd);
            
            assert n2/gcd*gcd == n2;
            
            assert false;
          }
          assert true == divide(a*b, gcd);
          open coprime(n1, n2);
          assert gcd(n1, n2) == 1;
          close coprime(n1, n2);
          assert gcd > gcd(n1, n2);
          
          gcd_holds(n1, n2, gcd);
          
          assert false;
        }
        if(a == 1) {
          if(b != n2) {
            open protect(n2 == b*a);
            assert n2 == b * a;
            assert false;
          } else {
            open protect(n2 == b*a);
          }
          assert b == n2;
          
          if(gamma != k1) {
            open protect(k1 == gamma * a);
            assert k1 == gamma * a;
            assert false;
          } else {
            open protect(k1 == gamma * a);
          }
          assert gamma == k1;
          assert gcd(gamma, b) == 1;
          close(coprime(gamma, b));
          assert gcd(n1, b) == 1;
          gcd_mul(n1, gamma, b);
          open(coprime(n1*gamma, b));
          assert gcd(n1*gamma, b) == 1;
          assert n1*gamma == x;
          assert x%n2 == 0;
          if(x == 0)
          {
          } else {
            assert x == k2*n2;
            if(gcd(x, n2) < n2) {
              assert true == divide(x, n2);
              gcd_holds(x, n2, n2);
              divide_itself(n2);
              assert true == divide(n2, n2);
              assert false;
            }
            assert gcd(x, n2) >= n2;
          }
        } else { // a != 1
          open protect(n2 == b*a);
          open protect(k1 == gamma * a);
          open protect(k1 == gamma * a); // Dunno why it is twice here ?? oO
          
          assert gcd(n1, b) == 1;
          close coprime(n1, b);
          assert coprime(n1, b);
          
          assert k2*b == n1*gamma;
          mod_multiple(gamma, n1);
          mod_multiple(k2, b);
          
          if(k2*b >=  n1*b)
          {
            mul_mono(n1*b, k2*b, a);
            assert k2*b*a >= n1*b*a;
            assert b*a == n2;
            mul_subst(b*a, n2, k2);
            assert b*a*k2 == k2*n2;
            mul_assoc(k2, b, a);
            assert k2*b*a == k2*n2;
            
            mul_subst(b*a, n2, n1);
            mul_assoc(n1, b, a);
            assert k2*n2 >= n1*n2;
            assert x >= n1*n2;
            assert false;
          }
          
          if(k2*b < 0)
          {
            assert a > 0;
            mul_negative(k2*b, a);
            assert k2*b*a < 0;
            mul_assoc(k2, b, a);
            assert k2*b*a == k2*n2;
            assert false;
          }
          
          open protect(k1 == k1/n2*n2 + k1%n2);
          
          assert coprime(n1, b);
          assert a*b == n2;
          assert a > 1;
          mul_mono_strict(1, a, b);
          assert b < n2;
          assert b <= n2 - 1;
          assert int_of_nat(p_loop_counter) >= b;
          bin_chinese_remainder_theorem_helper(n1, b, k2*b, p_loop_counter);
          assert k2*b == 0;
          mul_subst(k2*b, 0, a);
          assert k2*b*a == 0;
          assert n2 == b * a;
          mul_subst(n2, b*a, k2);
          mul_assoc(k2, b, a);
          assert k2*n2 == 0;
          assert x == 0;
        } // end of if(a == 1) else 
      } // end if (k1%n2 == 0) else
    } // end if(x > 1);
  } // end if(x == 1) else;
  assert x != 1;
  assert false == (x > 1);
  assert false == (x >= 1);
  assert x >= 0;
  is_zero(x);
  assert x == 0;
  } // End of case succ(p_loop_counter);
  } // End of switch
}


// x = diff * step
lemma void bin_chinese_remainder_theorem(int n1, int n2, int x)
requires coprime(n1, n2) &*& 0 == x%n1 &*& 0 == x % n2 &*& x < (n1*n2) &*& n1 > 0 &*& n2 > 0 &*& x >= 0;
ensures x == 0 &*& coprime(n1, n2);
{
  bin_chinese_remainder_theorem_helper(n1, n2, x, nat_of_int(n2));
}

#endif 
