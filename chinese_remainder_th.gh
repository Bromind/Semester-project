#ifndef CHINESE_REMAINDER_TH
#define CHINESE_REMAINDER_TH

#include "up_to_conversions.gh"
#include "arith.gh"
#include "nth_prop.gh"
#include "modulo.gh"
#include <nat.gh>
#include <list.gh>

predicate protect(bool b) = b == true;
predicate coprime(int n1, int n2) = gcd(n1, n2) == 1;

fixpoint bool divide(int whole, int divisor)
{
  return whole/divisor * divisor == whole;
}

lemma void divide_itself(int whole)
requires whole > 0;
ensures true == divide(whole, whole);
{
  div_incr(0, whole);
  division_round_to_zero(0, whole);
}

lemma void one_divide_all(int whole)
requires true;
ensures divide(whole, 1) == true;
{
  div_rem(whole, 1);
}

lemma void divisor_below_n(int whole, int divisor)
requires divisor > whole &*& whole > 0 &*& divisor > 0;
ensures divide(whole, divisor) == false;
{
  division_round_to_zero(whole, divisor);
  assert whole/divisor == 0;
  mul_subst(0, whole/divisor, divisor);
}

fixpoint bool divisors_fp(int whole, pair<int, bool> n_divide)
{
  return divide(whole, fst(n_divide)) == snd(n_divide);
}

fixpoint bool common_divisors_fp(int whole1, int whole2, pair<int, bool> n_divide)
{
  return divide(whole1, fst(n_divide)) == divide(whole2, fst(n_divide)) && divide(whole1, fst(n_divide)) == true;
}

fixpoint list<pair<int, bool> > gen_divisors(nat bound, int whole)
{
  switch(bound) {
    case zero: return nil;
    case succ(p_bound): return cons(pair(int_of_nat(bound), divide(whole, int_of_nat(bound))), gen_divisors(p_bound, whole));
  }
}

lemma void gen_divisors_contains_1(nat bound, int whole)
requires gen_divisors(succ(bound), whole) == cons(?pair, ?tail);
ensures true == exists(gen_divisors(succ(bound), whole), (equals)(pair(1, true)));
{
  switch(bound) {
    case(zero): {
      assert int_of_nat(succ(bound)) == 1;
      one_divide_all(whole);
      assert pair == pair(1, true);
    }
    case(succ(p_bound)): {
      gen_divisors_contains_1(p_bound, whole);
      assert true == exists(tail, (equals)(pair(1, true)));
    }
  }
}

lemma void length_gen_divisors(nat bound, int whole)
requires true;
ensures length(gen_divisors(bound, whole)) == int_of_nat(bound);
{
  switch(bound) {
    case zero: 
    case succ(p_bound): length_gen_divisors(p_bound, whole);
  }
}

lemma void gen_divisor_contains_all_divisors_below_bound(nat bound, int whole, int divisor)
requires whole >= 0 &*& int_of_nat(bound) >= divisor &*& divisor > 0;
ensures divide(whole, divisor) ? true == exists(gen_divisors(bound, whole), (equals)(pair(divisor, true))) : true == exists(gen_divisors(bound, whole), (equals)(pair(divisor, false)));
{
  switch(bound) {
    case zero: 
    case succ(p_bound): {
      if(int_of_nat(bound) == divisor) {
        list<pair<int, bool> > divs = gen_divisors(bound, whole);
        pair<int, bool> hd = head(divs);
        assert divs == cons(pair(int_of_nat(bound), divide(whole, int_of_nat(bound))), gen_divisors(p_bound, whole));
      } else {
        gen_divisor_contains_all_divisors_below_bound(p_bound, whole, divisor);
      }
    }
  }
}

fixpoint bool snd_true(pair<int, bool> p)
{
  return snd(p) == true;
}

fixpoint bool leq_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) >= fst(b);
}

fixpoint bool geq_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) <= fst(b);
}

fixpoint bool greater_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) < fst(b);
}

fixpoint bool less_than(pair<int, bool> a, pair<int, bool> b)
{
  return fst(a) > fst(b);
}

fixpoint bool neq<t>(t a, t b)
{
  return a != b;
}

fixpoint bool equals<t>(t a, t b)
{
  return a == b;
}

lemma void gen_divisors_head_eq_bound(int whole, nat bound)
requires bound == succ(?p_bound);
ensures head(gen_divisors(bound, whole)) == pair(int_of_nat(bound), divide(whole, int_of_nat(bound)));
{
  assert gen_divisors(bound, whole) == cons(pair(int_of_nat(bound), divide(whole, int_of_nat(bound))), gen_divisors(p_bound, whole));
}

lemma void gen_divisor_order_head(int whole, nat gen_bound)
requires gen_bound == succ(?p_gen_bound);
ensures true == less_than(head(gen_divisors(succ(gen_bound), whole)), head(gen_divisors(gen_bound, whole)));
{
}

fixpoint bool nth_greater_than_succ(list<pair<int, bool> > lst, int index)
{
  return less_than(nth(index, lst), nth(index+1, lst));
}

lemma void all_divisors_in_gen_divisors(int whole, int n)
requires n > 0 &*& whole > 0;
ensures divide(whole, n) ? true == exists(gen_divisors(nat_of_int(whole), whole), (equals)(pair(n, true))) : true;
{
  if(n > whole) {
    divisor_below_n(whole, n);
  } else {
    gen_divisor_contains_all_divisors_below_bound(nat_of_int(whole), whole, n);
  }
}

lemma void gen_divisors_head(list<pair<int, bool> > lst, nat bound, int whole)
requires lst == gen_divisors(bound, whole);
ensures bound == zero ? true : true == divisors_fp(whole, head(lst));
{
  length_gen_divisors(bound, whole);
  assert length(lst) == int_of_nat(bound);
  switch(bound) {
    case zero:
    case succ(p_bound):
  } 
}

lemma void gen_divisors_tail(list<pair<int, bool> > lst, nat s_bound, int whole)
requires lst == gen_divisors(s_bound, whole) &*& s_bound == succ(?bound);
ensures tail(lst) == gen_divisors(bound, whole);
{
}

lemma void forall_gen_divisor_contains_divisors(list<pair<int, bool> > lst, int whole)
requires lst == gen_divisors(nat_of_int(length(lst)), whole);
ensures true == forall(lst, (divisors_fp)(whole));
{
  switch(lst) {
    case nil:
    case cons(pair, tl): {
      gen_divisors_tail(lst, succ(nat_of_int(length(tl))), whole);
      forall_gen_divisor_contains_divisors(tl, whole);
      assert true == forall(tl, (divisors_fp)(whole));
    }
  }
}

fixpoint bool list_contains<t>(t elem, list<t> ls)
{
  switch(ls) {
    case nil : return false;
    case cons(hd, tl): return hd == elem ? true : list_contains(elem, tl);
  }
}

lemma void list_contains_nth<t>(list<t> lst, int n)
requires n >= 0 &*& n < length(lst);
ensures true == list_contains(nth(n, lst), lst);
{
  switch(lst){
    case nil: {
      assert false;
    }
    case cons(hd, tl): {
      if(n == 0) {
        assert nth(n, lst) == hd;
      } else {
        list_contains_nth(tl, n-1);
      }
    }
  }
}

lemma void list_exists_equal_to_contains<t>(list<t> ls, t elem)
requires true == exists(ls, (equals)(elem));
ensures true == list_contains(elem, ls);
{
  switch(ls){
    case nil: 
    case cons(hd, tl): {
      if(exists(tl, (equals)(elem)) == false) {
        if(equals(elem, hd) == false) {
        }
      } else {
        list_exists_equal_to_contains(tl, elem);
      }
    }
  }
}

fixpoint bool not<t>(fixpoint(t, bool) fp, t elem) 
{
  return fp(elem) == false;
}

lemma void not_exists_prop_to_not_exists<t>(list<t> lst, fixpoint(t, bool) prop, t elem)
requires false == exists(lst, prop) &*& true == prop(elem);
ensures false == exists(lst, (equals)(elem));
{
  switch(lst)
  {
    case nil:
    case cons(hd, tl): {
      if(hd == elem){}
      not_exists_prop_to_not_exists(tl, prop, elem);
    }
  }
}

lemma void contains_elem_to_exist_prop<t>(list<t> lst, t elem, fixpoint(t, bool) prop)
requires prop(elem) == true &*& true == list_contains(elem, lst);
ensures true == exists(lst, prop);
{
  switch(lst) {
    case nil:
    case cons(hd, tl): {
      if(hd == elem) {
      } else {
        contains_elem_to_exist_prop(tl, elem, prop);
      }
    }
  }
}

lemma void forall_contains_to_prop<t>(list<t> lst, fixpoint(t, bool) prop, t elem)
requires true == forall(lst, prop) &*& true == list_contains(elem, lst);
ensures true == prop(elem);
{
  switch(lst) {
    case nil: 
    case cons(hd, tl): {
      if(hd == elem) {
      } else {
        forall_contains_to_prop(tl, prop, elem);
      }
    }
  }
}

fixpoint list<pair<int, bool> > merge_list_and(list<pair<int, bool> > lst1, list<pair<int, bool> > lst2)
{
  switch(lst1) {
    case nil: return nil;
    case cons(pair, tail): return list_contains(pair, lst2) && snd(pair) == true ? cons(pair, merge_list_and(tail, lst2)) : merge_list_and(tail, lst2);
  }
}

lemma void merge_list_and_lemma_true(list<pair<int, bool> > lst1, list<pair<int, bool> > lst2)
requires true;
ensures true == forall(merge_list_and(lst1, lst2), snd_true);
{
  switch(lst1){
    case nil:
    case cons(hd, tl): {
      merge_list_and_lemma_true(tl, lst2);
    }
  }
}

lemma void merge_list_and_lemma(list<pair<int, bool> > lst1, list<pair<int, bool> > lst2, pair<int, bool> pair)
requires true == exists(lst1, (equals)(pair)) &*& true == exists(lst2, (equals)(pair)) &*& snd(pair) == true;
ensures true == exists(merge_list_and(lst1, lst2), (equals)(pair));
{
  switch(lst1) {
    case nil: assert false;
    case cons(hd, tl): {
      if(hd == pair) {
        list_exists_equal_to_contains(lst2, pair);
      } else {
        merge_list_and_lemma(tl, lst2, pair);
      }
    }
  }
}

lemma void merge_list_and_lemma_converse(list<pair<int, bool> > lst1, list<pair<int, bool> > lst2, pair<int, bool> pair)
requires true == list_contains(pair, merge_list_and(lst1, lst2));
ensures true == list_contains(pair, lst1) &*& true == list_contains(pair, lst2);
{
  switch(lst1)
  {
    case nil:
    case cons(hd, tl): {
      merge_list_and_lemma_true(lst1, lst2);
      if(hd == pair) {
        if(list_contains(hd, lst2)) {
        } else {
          forall_contains_to_prop(merge_list_and(lst1, lst2), snd_true, hd);
          merge_list_and_lemma_converse(tl, lst2, pair);
          assert snd(hd) == true;
          assert false == list_contains(pair, merge_list_and(lst1, lst2));
        }
      } else {
        merge_list_and_lemma_converse(tl, lst2, pair);
      }
    }
  }
}

lemma void common_divisors_contains_1(int n1, int n2)
requires n1 > 0 &*& n2 > 0;
ensures true == exists(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)), (equals)(pair(1, true)))
	&*& true == list_contains(pair(1, true), merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)));
{
  gen_divisors_contains_1(nat_of_int(n1-1), n1);
  gen_divisors_contains_1(nat_of_int(n2-1), n2);
  merge_list_and_lemma(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2), pair(1, true));
  list_exists_equal_to_contains(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)), pair(1, true));
}

lemma void common_divisors_contains_all_divisors(int n1, int n2, int n3)
requires divide(n1, n3) == true && divide(n2, n3) == true &*& n1 > 0 &*& n2 > 0 &*& n3 > 0;
ensures true == exists(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)), (equals)(pair(n3, true)));
{
  if(n3 > n1)
  {
    divisor_below_n(n1, n3);
  }
  gen_divisor_contains_all_divisors_below_bound(nat_of_int(n1), n1, n3);
  assert true == exists(gen_divisors(nat_of_int(n1), n1), (equals)(pair(n3, true)));
  
  if(n3 > n2)
  {
    divisor_below_n(n2, n3);
  }
  gen_divisor_contains_all_divisors_below_bound(nat_of_int(n2), n2, n3);
  assert true == exists(gen_divisors(nat_of_int(n2), n2), (equals)(pair(n3, true)));
  
  merge_list_and_lemma(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2), pair(n3, true));
}

lemma void common_divisors_up_to(list<pair<int, bool> > lst1, int n1, list<pair<int, bool> > lst2, int n2, list<pair<int, bool> > merged)
requires lst1 == gen_divisors(nat_of_int(n1), n1) 
	&*& lst2 == gen_divisors(nat_of_int(n2), n2)
	&*& merged == merge_list_and(lst1, lst2);
ensures true == up_to(nat_of_int(length(merged)), (forall_fp_to_up_to_fp)((common_divisors_fp)(n1, n2), merged));
{
  int i = 0;
  fixpoint(int, bool) fp = (forall_fp_to_up_to_fp)((common_divisors_fp)(n1, n2), merged);
  
  for(; i < length(merged); i++)
  invariant true == up_to(nat_of_int(i), (forall_fp_to_up_to_fp)((common_divisors_fp)(n1, n2), merged))
  	&*& i <= length(merged)
  	&*& i >= 0;
  decreases length(merged) - i;
  {
    assert true == up_to(nat_of_int(i), fp);
    list_contains_nth(merged, i);
    merge_list_and_lemma_true(lst1, lst2);
    forall_fp_to_fp(merged, snd_true, nat_of_int(i));
    assert snd(nth(i, merged)) == true;
    
    merge_list_and_lemma_converse(lst1, lst2, nth(i, merged));
    
    length_gen_divisors(nat_of_int(n1), n1);
    forall_gen_divisor_contains_divisors(lst1, n1);
    forall_contains_to_prop(lst1, (divisors_fp)(n1), nth(i, merged));
    
    length_gen_divisors(nat_of_int(n2), n2);
    forall_gen_divisor_contains_divisors(lst2, n2);
    forall_contains_to_prop(lst2, (divisors_fp)(n2), nth(i, merged));
    
    assert divide(n1, fst(nth(i, merged))) == true;
    assert divide(n2, fst(nth(i, merged))) == true;
    assert common_divisors_fp(n1, n2, nth(i, merged)) == true;
    assert true == fp(int_of_nat(nat_of_int(i)));
    succ_int(i);
  }
}

lemma void common_divisors(list<pair<int, bool> > lst1, int n1, list<pair<int, bool> > lst2, int n2)
requires lst1 == gen_divisors(nat_of_int(n1), n1) &*& lst2 == gen_divisors(nat_of_int(n2), n2);
ensures true == forall(merge_list_and(lst1, lst2), (common_divisors_fp)(n1, n2));
{
  common_divisors_up_to(lst1, n1, lst2, n2, merge_list_and(lst1, lst2));
  up_to_length_to_forall(merge_list_and(lst1, lst2), 0, merge_list_and(lst1, lst2), (common_divisors_fp)(n1, n2));
}


fixpoint pair<int, bool> greatest_common_divisor(list<pair<int, bool> > common_divisors)
{
  switch(common_divisors) {
    case nil: return pair(0, false);
    case cons(pair, tail): return snd(pair) == true && (greater_than(greatest_common_divisor(tail), pair) || snd(greatest_common_divisor(tail)) == false) ? pair : greatest_common_divisor(tail);
  }
}

lemma void greatest_common_divisor_in_common_divisors(list<pair<int, bool> > common_divisors)
requires true;
ensures greatest_common_divisor(common_divisors) == pair(0, false) || list_contains(greatest_common_divisor(common_divisors), common_divisors);
{
  switch(common_divisors)
  {
    case nil:
    case cons(pair, tail): {
      greatest_common_divisor_in_common_divisors(tail);
    }
  }
}

lemma void greatest_common_divisor_tail_less_than(list<pair<int, bool> > lst)
requires true;
ensures false == leq_than(greatest_common_divisor(lst), greatest_common_divisor(tail(lst))) ? snd(greatest_common_divisor(tail(lst))) == false : true;
{
  switch(lst){
    case nil:
    case cons(hd, tl): {
      pair<int, bool> gcd = greatest_common_divisor(lst);
      pair<int, bool> p_gcd = greatest_common_divisor(tail(lst));
      
      if(snd(p_gcd) == true){
        if(snd(hd) == false) {
        } else {
        } 
      } else { // snd(p_gcd) == false;
        if(snd(hd) == false) {
        } else {
        }
      }
    }
  }
}

lemma void greatest_common_divisor_return_true_divisor_iff_exists(list<pair<int, bool> > lst)
requires true;
ensures true == exists(lst, snd_true) ? snd(greatest_common_divisor(lst)) == true : snd(greatest_common_divisor(lst)) == false;
{
  switch(lst)
  {
    case nil:
    case cons(hd, tl): {
      greatest_common_divisor_return_true_divisor_iff_exists(tl);
    }
  }
}

lemma void greatest_common_divisor_l(list<pair<int, bool> > common_divisors, int n3)
requires greatest_common_divisor(common_divisors) == pair(?gcd, ?true_divisor) &*& (n3 > gcd || true_divisor == false);
ensures false == exists(common_divisors, (equals)(pair(n3, true)));
{    
  switch(common_divisors){
    case nil:
    case cons(hd, tl): {
      if(true_divisor == true) {
        greatest_common_divisor_tail_less_than(common_divisors);
        greatest_common_divisor_l(tl, n3);
        assert greatest_common_divisor(tl) == pair(?p_gcd, ?p_true_divisor);
        assert hd != pair(n3, true);
      } else {
        greatest_common_divisor_return_true_divisor_iff_exists(common_divisors);
        if(true == exists(common_divisors, (equals)(pair(n3, true)))) {
          assert exists(common_divisors, snd_true) == false;
          assert true == snd_true(pair(n3, true));
          not_exists_prop_to_not_exists(common_divisors, snd_true, pair(n3, true));
        }
      }
    }
  }
}

fixpoint int gcd(int n1, int n2)
{
  return fst(greatest_common_divisor(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2))));
}

lemma void gcd_holds(int n1, int n2, int n3)
requires n3 > gcd(n1, n2) &*& n3 > 0 &*& n1 > 0 &*& n2 > 0;
ensures divide(n1, n3) == true ? divide(n2, n3) == false : true;
{
  if(divide(n1, n3) == true) {
    if(divide(n2, n3) == true) {
      common_divisors_contains_all_divisors(n1, n2, n3);
      greatest_common_divisor_l(merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2)), n3);
    }
  } 
}

lemma void gcd_geq_1(int n1, int n2) 
requires n1 > 0 &*& n2 > 0;
ensures gcd(n1, n2) >= 1;
{
  if(gcd(n1, n2) < 1) {
    one_divide_all(n1);
    one_divide_all(n2);
    gcd_holds(n1, n2, 1);
  }
}

lemma void gcd_divide(int n1, int n2)
requires n1 > 0 &*& n2 > 0;
ensures n1%gcd(n1, n2) == 0 &*& n2%gcd(n1, n2) == 0;
{
  list<pair<int, bool> > common_divisors = merge_list_and(gen_divisors(nat_of_int(n1), n1), gen_divisors(nat_of_int(n2), n2));
  common_divisors_contains_1(n1, n2);
  contains_elem_to_exist_prop(common_divisors, pair(1, true), snd_true);
  
  assert true == exists(common_divisors, snd_true);
  greatest_common_divisor_return_true_divisor_iff_exists(common_divisors);
  greatest_common_divisor_in_common_divisors(common_divisors);
  
  assert list_contains(greatest_common_divisor(common_divisors), common_divisors) == true;
  common_divisors(gen_divisors(nat_of_int(n1), n1), n1, gen_divisors(nat_of_int(n2), n2), n2);
  
  forall_contains_to_prop(common_divisors, (common_divisors_fp)(n1, n2), greatest_common_divisor(common_divisors));
  
  assert true == common_divisors_fp(n1, n2, greatest_common_divisor(common_divisors));
  assert gcd(n1, n2) == fst(greatest_common_divisor(common_divisors));
  int gcd = gcd(n1, n2);
  gcd_geq_1(n1, n2);
  assert true == divide(n1, gcd);
  assert true == divide(n2, gcd);
  assert true == (n2/gcd*gcd == n2);
  close protect(n2/gcd*gcd == n2);
  
  
  assert n1/gcd*gcd == n1;
  assert gcd != 0;
  div_rem(n1, gcd);
  
  
  assert true == divide(n2, gcd);
  open protect(n2/gcd*gcd == n2);
  assert n2/gcd*gcd == n2;
  div_rem(n2, gcd);
  assert n2 == n2/gcd*gcd + n2%gcd;
  assert n2/gcd*gcd == n2/gcd*gcd + n2%gcd;
}

lemma void x_not_1(int n1, int n2, int x)
requires 0 == x%n1 &*& 0 == x%n2 &*& x < (n1*n2) &*& n1 > 0 &*& n2 > 0;
ensures x != 1;
{
  assert x != n1*n2;
  note(x != n1*n2);
  close protect(x != n1*n2);
  if(x == 1) {
    if(n1 > 1) {
      division_round_to_zero(1, n1);
      div_rem(1, n1);
      assert x%n1 == 1;
      assert false;
    }
    
    if(n2 > 1) {
      division_round_to_zero(1, n2);
      div_rem(1, n2);
      assert x%n2 == 1;
      assert false;
    }
    assert n1*n2 == 1;
    assert x == n1*n2;
    open protect(x != n1*n2);
  } else {
    open protect(x != n1*n2);
  }
}


lemma void mul_assoc(int n1, int n2, int n3)
requires true;
ensures n1*n2*n3 == n2*n3*n1;
{
  assume(false);
}

lemma void divide_inside_paren(int n1, int n2, int n3, int n4, int a)
requires n1 * (n2*a) == n3 * (n4 * a) &*& n1 >= 0 &*& n2 >= 0 &*& n3 >= 0 &*& n4 >= 0 &*& a > 0;
ensures n1 * n2 == n3 * n4;
{
  mul_assoc(a, n2, n1);
  mul_assoc(a, n4, n3);
  if(n1*n2 != n3*n4) {
    mul_nonnegative(n1, n2);
    mul_nonnegative(n3, n4);
    mul_subst_neq(n1*n2, n3*n4, a);
  }
}

lemma void mod_multiple(int n1, int n2)
requires n1 >= 0 &*& n2 > 0;
ensures 0 == (n1*n2)%n2;
{
  div_multiple(n1, n2);
  assert n1*n2/n2 == n1;

  int k = n1*n2;
  div_rem(k, n2);
  assert k == k/n2*n2 + k%n2;
  
  assert k == n1*n2 + k%n2;
}

lemma void gcd_mul(int n1, int n2, int n3)
requires coprime(n1, n3) &*& coprime(n2, n3);
ensures coprime(n1*n2, n3) &*& coprime(n1, n3) &*& coprime(n2, n3);
{
  assume(false);
}

lemma void close_div_rem(int a, int b)
requires b != 0;
ensures protect(a == a/b*b + a%b);
{
  div_rem(a, b);
  close protect(a == a/b*b + a%b);
}

lemma void is_zero(int x)
requires x >= 0 &*& false == (x >= 1);
ensures x == 0;
{
}

// x = diff * step
lemma void bin_chinese_remainder_theorem_helper(int n1, int n2, int x, nat loop_counter)
requires coprime(n1, n2) &*& 0 == x%n1 &*& 0 == x % n2 &*& x < (n1*n2) &*& n1 > 0 &*& n2 > 0 &*& x >= 0 &*& n2 <= int_of_nat(loop_counter);
ensures x == 0 &*& coprime(n1, n2);
{
  switch(loop_counter) {
  case zero: {
    assert n2 > 0;
    assert int_of_nat(loop_counter) == 0;
    assert n2 <= 0;
    
    assert false;
  }
  
  case succ(p_loop_counter): {
 
  if(1 == x) { // contradiction
    x_not_1(n1, n2, x);
  } else {
    assert x >= 0;
    if(x > 1) {
      close_div_rem(x, n1);
      close_div_rem(x, n2);
    
      int k1 = x/n1;
      quotient_positive(x, n1);
      int k2 = x/n2;
      int alpha = k2;
      
      open protect(x == x/n1*n1 + x%n1);
      assert x == k1*n1;
      close protect(x == k1*n1);
      if(k1 == 0){
        assert k1*n1 == 0;
        open protect(x == k1*n1);
        assert x == 0;
        //close protect(x == k1*n1);
        open protect(x > 1);
        assert false;
      } else {
        open protect(x == k1*n1);
      }
      open protect(x == x/n2*n2 + x%n2);
      assert x == k2*n2;
      close protect(x == k2*n2);
      assert k1*n1 == k2*n2;
    
      close_div_rem(k1, n2);
      open protect(k1 == k1/n2*n2 + k1%n2);
      note(k1 == k1/n2*n2 + k1%n2);
      close protect(k1 == k1/n2*n2 + k1%n2);
      
      int beta = k1/n2;
      assert k1 == n2*beta + k1%n2;
      note(k1 == n2*beta + k1%n2);
      
      if(k1%n2 == 0) {
        if(beta == 0) { // Prove that x == 0
          assert n2*beta == 0;
          assert k1%n2 == 0;
          assert beta == k1/n2;
          open protect(k1 == k1/n2*n2 + k1%n2);
          assert k1 == n2*beta + k1%n2;
          assert k1 == 0;
          open protect(x == k1*n1);
          assert x == k1*n1;
          assert x == 0*n1;
          assert x == 0;
        } else { // contradiction
          quotient_positive(x, n1);
          quotient_positive(x/n1, n2);
          assert beta >= 1;
          assert k1 == n2*beta;
          mul_mono(1, beta, n2);
          assert k1 >= n2;
          mul_mono(n2, k1, n1);
          assert x >= n1*n2;
          assert false;
        }
      } else { // k1%n2 != 0
        int a = gcd(k1, n2);
        quotient_positive(x, n1);
        gcd_geq_1(k1, n2);
        div_rem(n2, a);
        int b = n2/a;
        quotient_positive(n2, a);
        close protect(n2 == b* a + n2%a);
        assert n2 == b * a + n2%a;
        gcd_divide(k1, n2);
        assert n2%a == 0;
        open protect(n2 == b * a + n2%a);
        assert n2 == b * a;
        close protect(n2 == b* a + n2%a);
        note(n2 == b*a);
        
        div_rem(k1, a);
        int gamma = k1/a;
        quotient_positive(k1, a);
        assert k1 == gamma * a;
        note(k1 == gamma * a);
        close protect(k1 == gamma * a);
       
        if(gcd(b, gamma) != 1)
        {
          assume(false);
        }
        open protect(x == k1*n1);
        close protect(k1 == gamma * a);
        open protect(x == k2*n2);
        assert k1 * n1 == k2 * n2;
        assert n2 == b * a;
        close protect(n2 == b*a);
        quotient_positive(x, n2);
        mul_subst(n2, b*a, k2);
        assert k1 * n1 == k2 * (b * a);
        assert n1 * (gamma * a) == k2 * (b * a);
        divide_inside_paren(n1, gamma, k2, b, a);
        assert n1 * gamma == k2 * b;
        if(gcd(n1, b) != 1) {
          assume(false);
        }
        if(a == 1) {
          if(b != n2) {
            open protect(n2 == b*a);
            assert n2 == b * a;
            assert false;
          } else {
            open protect(n2 == b*a);
          }
          assert b == n2;
          
          if(gamma != k1) {
            open protect(k1 == gamma * a);
            assert k1 == gamma * a;
            assert false;
          } else {
            open protect(k1 == gamma * a);
          }
          assert gamma == k1;
          assert gcd(gamma, b) == 1;
          close(coprime(gamma, b));
          assert gcd(n1, b) == 1;
          gcd_mul(n1, gamma, b);
          open(coprime(n1*gamma, b));
          assert gcd(n1*gamma, b) == 1;
          assert n1*gamma == x;
          assert x%n2 == 0;
          if(x == 0)
          {
          } else {
            assert x == k2*n2;
            if(gcd(x, n2) < n2) {
              assert true == divide(x, n2);
              gcd_holds(x, n2, n2);
              divide_itself(n2);
              assert true == divide(n2, n2);
              assert false;
            }
            assert gcd(x, n2) >= n2;
          }
        } else { // a != 1
          open protect(n2 == b*a);
          open protect(k1 == gamma * a);
          open protect(k1 == gamma * a); // Dunno why it is twice here ?? oO
          
          assert gcd(n1, b) == 1;
          close coprime(n1, b);
          assert coprime(n1, b);
          
          assert k2*b == n1*gamma;
          mod_multiple(gamma, n1);
          mod_multiple(k2, b);
          
          if(k2*b >=  n1*b)
          {
            mul_mono(n1*b, k2*b, a);
            assert k2*b*a >= n1*b*a;
            assert b*a == n2;
            mul_subst(b*a, n2, k2);
            assert b*a*k2 == k2*n2;
            mul_assoc(k2, b, a);
            assert k2*b*a == k2*n2;
            
            mul_subst(b*a, n2, n1);
            mul_assoc(n1, b, a);
            assert k2*n2 >= n1*n2;
            assert x >= n1*n2;
            assert false;
          }
          
          if(k2*b < 0)
          {
            assert a > 0;
            mul_negative(k2*b, a);
            assert k2*b*a < 0;
            mul_assoc(k2, b, a);
            assert k2*b*a == k2*n2;
            assert false;
          }
          
          open protect(k1 == k1/n2*n2 + k1%n2);
          
          assert coprime(n1, b);
          assert a*b == n2;
          assert a > 1;
          mul_mono_strict(1, a, b);
          assert b < n2;
          assert b <= n2 - 1;
          assume (int_of_nat(p_loop_counter) <= b);
          assert int_of_nat(p_loop_counter) <= b;
          bin_chinese_remainder_theorem_helper(n1, b, k2*b, p_loop_counter);
          assert k2*b == 0;
          mul_subst(k2*b, 0, a);
          assert k2*b*a == 0;
          assert n2 == b * a;
          mul_subst(n2, b*a, k2);
          mul_assoc(k2, b, a);
          assert k2*n2 == 0;
          assert x == 0;
        } // end of if(a == 1) else 
      } // end if (k1%n2 == 0) else
    } // end if(x > 1);
  } // end if(x == 1) else;
  assert x != 1;
  assert false == (x > 1);
  assert false == (x >= 1);
  assert x >= 0;
  is_zero(x);
  assert x == 0;
  } // End of case succ(p_loop_counter);
  } // End of switch
}


// x = diff * step
lemma void bin_chinese_remainder_theorem(int n1, int n2, int x)
requires coprime(n1, n2) &*& 0 == x%n1 &*& 0 == x % n2 &*& x < (n1*n2) &*& n1 > 0 &*& n2 > 0 &*& x >= 0;
ensures x == 0 &*& coprime(n1, n2);
{
  bin_chinese_remainder_theorem_helper(n1, n2, x, nat_of_int(n2));
}

#endif 